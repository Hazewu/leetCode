1、把程序存储在计算机中，程序必须记住3个基本属性：
  1、信息将存储在哪里；位置；
  2、要存储什么值；值；
  3、存储何种类型的信息；类型；

2、以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用；
  以一个下划线开头的名称被保留给实现，用作全局标识符；
  简单命名规则：
  1、在名称中只能使用字母字符、数字和下划线；
  2、名称的第一个字符不能是数字；
  3、区分大写字符与小写字符；
  4、不能将C++关键字用作名称；
  5、名称的长度没有限制，名称中所有的字符都有意义；

3、在C++所有主观的风格中，一致性和精度是最重要的；
  一些前缀：
  1、n（表示整数值）；
  2、str或sz（表示以空字符结束的字符串）；
  3、b（表示布尔值）；
  4、p（表示指针）；
  5、c（表示单个字符）；
  6、m（表示类成员）；

4、位与字节：
  计算机内存的基本单元是位（bit）；0表示关，1表示开；
  8位单元可以表示0-255，或者-128到127；

  字节（byte）通常指的是8位的内存单元；1KB=1024byte，1MB=1024KB；

5、整型，计算机设计的要求，不同计算机可能不同：
  short至少16位；
  int至少与short一样长；
  long至少32位，且至少与int一样长；
  long long至少64位，且至少与long一样长；

6、在程序中使用C++工具来检查类型的长度；
  sizeof运算符，返回类型或变量的长度，单位为字节；
    1、对类型名使用运算符时，应将名称放在括号中；
    2、对变量名使用该运算符时，括号是可选的；
  头文件climits包含了关于整型限制的信息；在p41中有大小符号常量的总结；
    符号常量-预处理器方式，#define INT_MAX 32767；该编译指令告诉预处理器：在程序中查找INT_MAX，并将所有的INT_MAX都替换为32767；
    在C++中可以使用const来定义常量，在C和C++中都可以使用#define；

7、初始化：初始化将赋值与声明合并在一起；
  可以使用字面值来初始化；字面值1，32，331，42，不是变量；
  可以使用变量来初始化，条件是该变量已经定义过；
  可以使用表达式来初始化变量，条件是当程序执行到该声明时，表达式中所有的值都是已知的；
  C++的另一种初始化语法：int wrens(432);

8、C++11初始化方式，用于数组和结构；
  1、int num{7}；int num={17}；采取大括号初始化器，可以使用等号，也可以不使用；
  2、int rocs={}；int psychice{}；大括号内可以不包含任何东西，变量将被初始化为零；
  3、大括号初始化器，可以用于任何类型；

9、无符号类型，不能存储负数值的无符号变体，其优点是可以增大变量能够存储的最大值；
  使用unsigned关键字来修改声明即可；
  为了防止溢出（上溢出、下溢出）时不出错，C++设置了重置点；
    1、无符号数的重置点，0，再减小，重置为最大值，进行运算；
    2、有符号数的重置点，最大值，再增大，重置为最小值，进行运算；

10、在vs中，一个项目有多个cpp，多个main函数，可以让其他cpp的属性--》常规--》从生成中排除--》选择是，即可；

11、通常，int被设置为对目标计算机而言最为“自然”的长度；
  自然长度（natural-size）指的是计算机处理起来效率最高的长度；如果没有非常有说服力的理由来选择其他类型，则应使用int；
  如果只需要一个字节，可使用char；

12、整型字面值，是显示地书写的常量；可以有基数为10、基数为8、基数为16；
  十进制；
  八进制：第一位是0，第二位是1~7；
  十六进制：前两位为0x或者0X；
  默认情况下，cout以十进制格式显示整数；
  cout可以指定显示方式，hex、oct；需要与endl配合使用，endl用于指示cout重起一行；

13、编译器如何知道常量的类型；
   整型常量一般存储为int；
   后缀：
     1、l或L，表示long常量；
     2、u或U，表示unsigned int常量；
     3、ul，大小写皆可，表示unsigned long常量；
     4、u、L、L可以组合表示；

14、char一个字节，8位，比short更小的整型；
  C++实现，使用的是其主机系统的编码：有可能是ASCII，有可能是EBCDIC，有可能是Unicode；
  对字符用单引号；这种表示法代表大是字符的数值编码；
  对字符串使用双引号；
  cout.put()函数，显示一个字符；
  对于一些不能直接通过键盘输入到程序中的字符，可以通过转义序列来表示；单个这样的字符，仍然用单引号；
  \b，退格；
  \a，振铃；

15、char在默认情况下既不是没有符号，也不是有符号，是否有符号由C++实现决定；
  这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来；
  如果char有某种特定的行为，需要显示地将类型设置为signed char或unsigned char；

  wchar_t，是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集；
  wcin和wcout用于处理wchar_t流；

  char16_t，无符号，长16位；u前缀表示；
  char32_t，有符号，长32位；U前缀表示；

16、bool值：true（非零值）、false（零）；

17、const限定符；
  符号名称指出了常量表示的内容；
  如果程序在多个地方使用同一个常量，则需要修改该常量时，只需要修改一个符号定义即可；
  常量被初始化后，其值就被固定了，编译器将不允许再修改该常量的值；
  const比#define好，
    1、它能明确指定类型；
    2、可以使用C++的作用域规则将定义限制在特定的函数或文件中；
    3、可以将const作用域更复杂的类型；

18、浮点数：能够表示小数值、非常大和非常小的值；
  书写方式：
	1、标准小数点表示法；12.34、0.00023；
	2、E表示法；3.34E6，E/e后面可以是负数；科学表示法；
	ddddE+n，表示将小数点向右移n位；
	ddddE~n，表示将小数点向左移n位；
  浮点类型，有效位的差异：
    1、float；
    2、double；
    3、long double；
  可以用ios_base::fixed和ios_base::floatfield输出固定的有效位；
  通常cout会删除小数点后结尾的零，调用cout.setf()将覆盖这种行为，不会删除结尾的零；
  cout所属的ostream类有一个类成员函数，能够精确地控制输出的格式--字段宽度、小数位数、采用小数格式还是E格式；
  浮点常量：
    1、24.32f；float类型；
    2、53.2；什么都不写，默认double类型；
    3、2.2L；long double类型；
  浮点数优点：可以表示整数之间的值；表示范围大；
  浮点数缺点：浮点运算的速度通常比整数运算慢，且精度降低；

19、多阅读包含的头文件，不要将包含文件作为神秘的知识而依赖；

20、算术运算符：加法、减法、乘法、除法/、求模%；
  求模，两个操作数只能是整数；



  自动化
  1、达到的效果：拿到一个应用可以快速复制到测试环境、进行测试；
  2、步骤：
    1、先拿到应用的模型参数；数据模型+业务数据（业务数据可能不拿）-----3、再模型层---需要解释器、类似于python解释器
    2、按照参数在测试环境搭建应用，造数据；--------------------------2
    3、验证功能数据扭转；需要验证哪些东西，直接读取；-----------------1、先推数据层、控件级、表级、应用级
    4、用例分层级去维护；配置解析；
    5、（接口封装、提供调用、大语义模块、小语义模块）语义层、（生产环境的应用配置）配置层、（测试时需要用的数据）数据层；
    6、动态生成数据；动态解析的东西有点多；-------这里有没有好方案？
    7、针对不同的数据、可以用同一套脚本去跑吗？
    8、脚本清单；需要组合测试用例、组合脚本；
    9、测试点；多个人员操作；权限设置；
    10、用例的串行、操作的依赖；
    11、一个应用一个套件；一个应用会有多条测试场景、即测试用例；
    12、发现出、不同的用户、不一样的地方；
    13、快速响应用户；
    14、生成测试用例的规则；测试数据的规则；-------------都来源于配置层；
    15、静态场景、动态场景（多个静态场景的串、需要动态解析）；
    16、模型修改能力；
    17、BFF聚合后端的接口，让前端一个操作只调用一个接口；后端只提供聚合接口；
    18、封装操作的原子化接口；
    19、用接口来应对变化；就是应该做的事！facade外观者或者中介者来管理；
    20、考虑事件触发？

    1、最小粒度；
    2、需要做什么事、这样做有什么意义、怎么实现；
    3、步骤：自顶向下
      1、创建应用--------需要测什么；
      2、创建表---------需要测什么；具体针对表
      3、创建控件-------需要测什么；具体针对已经创建的字段，读配置；
      4、创建工作流------需要测什么；2、3、4可能有联系；
      5、创建视图---------需要测什么；
      6、创建权限---------需要测什么；
      7、综合测试；
    4、自底向上；
    5、责任链；打移动电话；解释器模式；
    6、构造数据的能力；校验的数据；校验的能力；
    7、解析配置------解析出什么东西-------测试用例；

    App---》（解析）----》config----》（生成测试）---》data、验证data----》（执行）----》list----》（验证）---》验证数据；